<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Игра 2048</title>
    <!-- Подключение Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Настройка шрифта Inter и цветов Tailwind -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-top: 2rem;
            padding-bottom: 2rem;
        }

        .game-grid {
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            aspect-ratio: 1 / 1; /* Обеспечивает квадратную форму */
        }

        .tile {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            color: #776e65;
            transition: transform 100ms ease-in-out, background-color 100ms ease-in-out;
            user-select: none;
            cursor: default;
        }

        /* Цветовая палитра для плиток */
        .tile-0 { background-color: #cdc1b4; font-size: 0; color: #cdc1b4;} /* Empty cell */
        .tile-2 { background-color: #eee4da; font-size: 1.5rem; color: #776e65; }
        .tile-4 { background-color: #ede0c8; font-size: 1.5rem; color: #776e65; }
        .tile-8 { background-color: #f2b179; font-size: 1.5rem; color: #f9f6f2; }
        .tile-16 { background-color: #f59563; font-size: 1.5rem; color: #f9f6f2; }
        .tile-32 { background-color: #f67c5f; font-size: 1.5rem; color: #f9f6f2; }
        .tile-64 { background-color: #f65e3e; font-size: 1.5rem; color: #f9f6f2; }
        .tile-128 { background-color: #edcf72; font-size: 1.25rem; color: #f9f6f2; }
        .tile-256 { background-color: #edcc61; font-size: 1.25rem; color: #f9f6f2; }
        .tile-512 { background-color: #edc850; font-size: 1.25rem; color: #f9f6f2; }
        .tile-1024 { background-color: #edc53f; font-size: 1rem; color: #f9f6f2; }
        .tile-2048 { background-color: #edc22e; font-size: 1rem; color: #f9f6f2; }
        /* Larger tiles have smaller font size to fit */
        .tile-4096, .tile-8192, .tile-16384 { background-color: #3c3a32; font-size: 0.8rem; color: #f9f6f2; }

        /* Mobile font size adjustments */
        @media (min-width: 640px) {
            .tile-2, .tile-4, .tile-8, .tile-16, .tile-32, .tile-64 { font-size: 2rem; }
            .tile-128, .tile-256, .tile-512 { font-size: 1.75rem; }
            .tile-1024, .tile-2048 { font-size: 1.5rem; }
            .tile-4096, .tile-8192, .tile-16384 { font-size: 1.25rem; }
        }

        /* Overlay for game end */
        #gameOverOverlay {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(2px);
        }
    </style>
</head>
<body class="bg-gray-50">

    <div id="app" class="w-full max-w-sm p-4 sm:p-6 space-y-4">
        <!-- Header and Scoreboard -->
        <header class="flex justify-between items-center mb-4">
            <h1 class="text-4xl font-black text-[#776e65]">2048</h1>
            <div class="flex space-x-2">
                <!-- Score Card -->
                <div class="bg-[#bbada0] p-2 rounded-lg text-center min-w-[70px]">
                    <div class="text-xs font-bold uppercase text-[#eee4da]">СЧЕТ</div>
                    <div id="score" class="text-xl font-bold text-white">0</div>
                </div>
                <!-- Best Score Card -->
                <div class="bg-[#bbada0] p-2 rounded-lg text-center min-w-[70px] hidden sm:block">
                    <div class="text-xs font-bold uppercase text-[#eee4da]">ЛУЧШИЙ</div>
                    <div id="bestScore" class="text-xl font-bold text-white">0</div>
                </div>
            </div>
        </header>

        <!-- Game Description and New Game Button -->
        <div class="flex justify-between items-center text-[#776e65] mb-4">
            <p class="text-sm">
                Свайпайте (или используйте стрелки) для объединения плиток.
                Цель: <span class="font-bold">2048</span>.
            </p>
            <button id="newGameButton"
                    class="px-4 py-2 bg-[#8f7a66] text-white font-bold rounded-lg hover:bg-[#9f8a76] transition shadow-lg">
                Новая игра
            </button>
        </div>

        <!-- Game Board Container -->
        <div class="relative bg-[#bbada0] p-3 rounded-xl shadow-2xl">
            <!-- Game Grid -->
            <div id="gameGrid" class="game-grid grid gap-3">
                <!-- Tiles will be generated here by JavaScript -->
            </div>

            <!-- Game Over Overlay (Hidden initially) -->
            <div id="gameOverOverlay" class="absolute inset-0 flex flex-col justify-center items-center rounded-xl transition duration-300 hidden">
                <p id="gameOverMessage" class="text-4xl font-bold text-[#776e65] mb-4 text-center"></p>
                <button id="tryAgainButton"
                        class="px-6 py-3 bg-[#8f7a66] text-white font-bold rounded-lg text-xl hover:bg-[#9f8a76] transition shadow-lg">
                    Попробовать снова
                </button>
            </div>
        </div>

        <!-- Instructions for Mini App (visible on mobile) -->
        <div class="text-center text-sm text-[#776e65] pt-4 block sm:hidden">
            <p>
                Для игры используйте свайпы на экране!
            </p>
        </div>
    </div>

    <script>
        // Глобальные переменные для состояния игры
        const GRID_SIZE = 4;
        let board = [];
        let score = 0;
        let bestScore = localStorage.getItem('bestScore2048') ? parseInt(localStorage.getItem('bestScore2048')) : 0;
        let isGameOver = false;

        // Элементы DOM
        const gameGrid = document.getElementById('gameGrid');
        const scoreDisplay = document.getElementById('score');
        const bestScoreDisplay = document.getElementById('bestScore');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const newGameButton = document.getElementById('newGameButton');
        const tryAgainButton = document.getElementById('tryAgainButton');

        // Переменные для обработки свайпов
        let touchstartX = 0;
        let touchstartY = 0;
        let touchendX = 0;
        let touchendY = 0;
        let isTouchMoved = false;

        // --- ИНИЦИАЛИЗАЦИЯ ИГРЫ ---

        /** Инициализирует игровое поле и запускает новую игру. */
        function initGame() {
            board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            score = 0;
            isGameOver = false;
            updateScore(0);
            updateBestScore(bestScore);
            gameOverOverlay.classList.add('hidden');
            gameOverOverlay.style.opacity = '0';

            // Создаем пустые ячейки для сетки (только один раз)
            gameGrid.innerHTML = '';
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('tile', 'tile-0', 'rounded-lg', 'font-extrabold', 'shadow-inner');
                gameGrid.appendChild(cell);
            }

            // Генерируем две стартовые плитки
            addRandomTile();
            addRandomTile();
            renderBoard();
        }

        /** Обновляет отображение счета. */
        function updateScore(newScore) {
            score = newScore;
            scoreDisplay.textContent = score;
            if (score > bestScore) {
                updateBestScore(score);
            }
        }

        /** Обновляет отображение лучшего счета и сохраняет его в localStorage. */
        function updateBestScore(newScore) {
            bestScore = newScore;
            bestScoreDisplay.textContent = bestScore;
            localStorage.setItem('bestScore2048', bestScore);
        }

        /** Добавляет плитку со значением 2 (90%) или 4 (10%) в случайную пустую ячейку. */
        function addRandomTile() {
            const emptyCells = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] === 0) {
                        emptyCells.push({ r, c });
                    }
                }
            }

            if (emptyCells.length > 0) {
                const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const newValue = Math.random() < 0.9 ? 2 : 4;
                board[r][c] = newValue;
            }
        }

        // --- РЕНДЕРИНГ ИГРЫ ---

        /** Обновляет DOM, чтобы соответствовать текущему состоянию игрового поля. */
        function renderBoard() {
            const cells = gameGrid.children;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const index = r * GRID_SIZE + c;
                    const tile = cells[index];
                    const value = board[r][c];

                    // Очистка классов
                    tile.className = '';
                    tile.classList.add('tile', 'rounded-lg', 'font-extrabold', 'shadow-inner');

                    // Добавление класса на основе значения
                    tile.classList.add(`tile-${value}`);

                    // Установка текста
                    tile.textContent = value > 0 ? value : '';
                }
            }
        }

        // --- ЛОГИКА ДВИЖЕНИЯ ---

        /**
         * Сдвигает и объединяет плитки в одном ряду/столбце.
         * @param {Array<number>} line - Ряд или столбец для обработки.
         * @param {number} direction - 1 для сдвига к началу (влево/вверх), -1 для сдвига к концу (вправо/вниз).
         * @returns {{newLine: Array<number>, points: number}}
         */
        function slideAndMerge(line, direction) {
            let points = 0;
            let moved = false;
            let currentLine = line.filter(val => val !== 0); // Убираем нули

            // 1. Слияние
            const processLine = [];
            let i = direction === 1 ? 0 : currentLine.length - 1;

            while (i >= 0 && i < currentLine.length) {
                const currentVal = currentLine[i];
                const nextVal = currentLine[i + direction];

                if (nextVal !== undefined && currentVal === nextVal) {
                    const mergedVal = currentVal * 2;
                    points += mergedVal;
                    processLine.push(mergedVal);
                    // Пропускаем следующую плитку, так как она была объединена
                    i += (direction === 1 ? 2 : -2);
                    moved = true;
                } else {
                    processLine.push(currentVal);
                    i += direction;
                }
            }

            // 2. Заполнение нулями
            const diff = GRID_SIZE - processLine.length;
            const newZeros = Array(diff).fill(0);

            let newLine;
            if (direction === 1) { // Сдвиг влево/вверх (нули справа)
                newLine = processLine.concat(newZeros);
            } else { // Сдвиг вправо/вниз (нули слева)
                newLine = newZeros.concat(processLine);
            }

            // Проверка, произошло ли фактическое перемещение (если не было слияния)
            if (!moved) {
                moved = line.some((val, index) => val !== newLine[index]);
            }

            return { newLine, points, moved };
        }


        /**
         * Выполняет ход в указанном направлении.
         * @param {string} direction - 'up', 'down', 'left', 'right'.
         */
        function makeMove(direction) {
            if (isGameOver) return;

            let totalPoints = 0;
            let hasMoved = false;
            let newBoard = board.map(row => [...row]); // Копия доски

            for (let i = 0; i < GRID_SIZE; i++) {
                let line;

                // Извлечение ряда/столбца
                if (direction === 'left' || direction === 'right') {
                    line = board[i];
                } else { // up/down
                    line = board.map(row => row[i]);
                }

                // Определение направления слияния
                const slideDirection = (direction === 'left' || direction === 'up') ? 1 : -1;
                const result = slideAndMerge(line, slideDirection);

                totalPoints += result.points;
                if (result.moved) {
                    hasMoved = true;
                }

                // Обновление нового поля
                if (direction === 'left' || direction === 'right') {
                    newBoard[i] = result.newLine;
                } else { // up/down
                    for (let j = 0; j < GRID_SIZE; j++) {
                        newBoard[j][i] = result.newLine[j];
                    }
                }
            }

            // Если произошло движение, обновляем состояние и добавляем новую плитку
            if (hasMoved) {
                board = newBoard;
                updateScore(score + totalPoints);
                addRandomTile();
                renderBoard();
                checkGameStatus();
            }
        }

        // --- ПРОВЕРКА СОСТОЯНИЯ ИГРЫ ---

        /** Проверяет, закончена ли игра (нет пустых ячеек и нет возможных ходов). */
        function checkGameStatus() {
            // 1. Проверка на 2048 (необязательно, но приятно)
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (board[r][c] === 2048) {
                        endGame(true); // Победа
                        return;
                    }
                }
            }

            // 2. Проверка на наличие пустых ячеек
            const emptyCellsExist = board.flat().includes(0);
            if (emptyCellsExist) {
                return; // Игра продолжается
            }

            // 3. Проверка на возможные слияния (соседние одинаковые плитки)
            if (canMove()) {
                return; // Есть возможные ходы
            }

            // Если пустых ячеек нет и ходов нет -> Поражение
            endGame(false);
        }

        /** Проверяет, есть ли вообще возможные ходы (слияния). */
        function canMove() {
            // Проверка по горизонтали
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE - 1; c++) {
                    if (board[r][c] === board[r][c + 1]) return true;
                }
            }

            // Проверка по вертикали
            for (let c = 0; c < GRID_SIZE; c++) {
                for (let r = 0; r < GRID_SIZE - 1; r++) {
                    if (board[r][c] === board[r + 1][c]) return true;
                }
            }
            return false;
        }

        /** Отображает экран окончания игры. */
        function endGame(isWin) {
            isGameOver = true;
            gameOverOverlay.classList.remove('hidden');
            gameOverOverlay.style.opacity = '1';

            if (isWin) {
                gameOverMessage.textContent = 'ПОБЕДА! 🎉';
            } else {
                gameOverMessage.textContent = 'ИГРА ОКОНЧЕНА 😟';
            }
        }

        // --- ОБРАБОТЧИКИ СОБЫТИЙ ---

        /** Обработка нажатий клавиш для настольных устройств. */
        document.addEventListener('keydown', (e) => {
            let direction = '';
            switch (e.key) {
                case 'ArrowUp':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                    direction = 'right';
                    break;
            }

            if (direction) {
                e.preventDefault(); // Предотвратить прокрутку страницы
                makeMove(direction);
            }
        });

        // Обработка тач-событий для мобильных устройств (Mini App)
        gameGrid.addEventListener('touchstart', (e) => {
            touchstartX = e.changedTouches[0].screenX;
            touchstartY = e.changedTouches[0].screenY;
            isTouchMoved = false;
        }, false);

        gameGrid.addEventListener('touchmove', (e) => {
            // Отслеживаем движение, чтобы отличить свайп от простого касания
            touchendX = e.changedTouches[0].screenX;
            touchendY = e.changedTouches[0].screenY;

            if (Math.abs(touchendX - touchstartX) > 10 || Math.abs(touchendY - touchstartY) > 10) {
                isTouchMoved = true;
            }
        }, false);

        gameGrid.addEventListener('touchend', (e) => {
            if (!isTouchMoved) return; // Игнорировать, если это было простое касание

            const dx = touchendX - touchstartX;
            const dy = touchendY - touchstartY;
            const threshold = 50; // Минимальное расстояние для свайпа

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold) {
                // Горизонтальный свайп
                makeMove(dx > 0 ? 'right' : 'left');
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > threshold) {
                // Вертикальный свайп
                makeMove(dy > 0 ? 'down' : 'up');
            }
            // Сброс isTouchMoved после обработки
            isTouchMoved = false;
        }, false);


        // Обработчик кнопки "Новая игра"
        newGameButton.addEventListener('click', initGame);
        tryAgainButton.addEventListener('click', initGame);

        // Запуск игры при загрузке страницы
        window.onload = initGame;
    </script>
</body>
</html>
